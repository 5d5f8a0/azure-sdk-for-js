/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
const { AzureQuotaExtensionAPI } = require("@azure/arm-quota");
const { DefaultAzureCredential } = require("@azure/identity");
require("dotenv").config();

/**
 * This sample demonstrates how to Request to assign quota from group quota to a specific Subscription. The assign GroupQuota to subscriptions or reduce the quota allocated to subscription to give back the unused quota ( quota >= usages) to the groupQuota. So, this API can be used to assign Quota to subscriptions and assign back unused quota to group quota, which can be assigned to another subscriptions in the GroupQuota.
 *
 * @summary Request to assign quota from group quota to a specific Subscription. The assign GroupQuota to subscriptions or reduce the quota allocated to subscription to give back the unused quota ( quota >= usages) to the groupQuota. So, this API can be used to assign Quota to subscriptions and assign back unused quota to group quota, which can be assigned to another subscriptions in the GroupQuota.
 * x-ms-original-file: specification/quota/resource-manager/Microsoft.Quota/preview/2023-06-01-preview/examples/SubscriptionQuotaAllocationRequests/PutSubscriptionQuotaAllocationRequest-Compute.json
 */
async function subscriptionQuotaAllocationPutRequestForCompute() {
  const subscriptionId ="65a85478-2333-4bbd-981b-1a818c944faf";
  const managementGroupId = "testMgIdRoot";
  const groupQuotaName = "sdk-test-group-quota";
  const resourceProviderName = "Microsoft.Compute";
  const resourceName = "standardav2family";
  const allocateQuotaRequest = {
    properties: {
      requestedResource: { properties: { limit: 10, region: "westus" } },
    },
  };
  const credential = new DefaultAzureCredential();
  const client = new AzureQuotaExtensionAPI(credential, subscriptionId);
  const result = await client.groupQuotaSubscriptionAllocationRequest.beginCreateOrUpdate(
    managementGroupId,
    groupQuotaName,
    resourceProviderName,
    resourceName,
    allocateQuotaRequest,
  );

  const rawResponse = JSON.parse(result.toString());
  const operationLocation = rawResponse.state.config.operationLocation;
  const requestId = operationLocation.split('/').pop().split('?')[0];

  const startTime = Date.now();
  const runTime = 5 * 60 * 1000; // 5 minutes in milliseconds
  const interval = 30 * 1000; // 30 seconds in milliseconds

  while (Date.now() - startTime < runTime) {
      // Your code to execute every 30 seconds
      const status = await client.groupQuotaSubscriptionAllocationRequest.get(
        managementGroupId,
        groupQuotaName,
        requestId,
      );

      //TODO change this since response body will change 
      var provisioningState = status?.provisioningState;
      console.log(provisioningState);
      var finalState = "";
      if( provisioningState != "Accepted" && provisioningState != "InProgress"){

        if( provisioningState == "Escalated"){
          finalState = provisioningState;
          console.info("Request has been escalated. Contact your capacity manager for next steps");
          break;
        }else if( provisioningState == "Failed"){
          finalState = provisioningState;
          console.info("Failed with FaultCode:" + status?.properties?.faultCode)
          break;
        }else{
          finalState = provisioningState;
          console.info("Request was successful");
          break;
        }
      }

      // Wait for 30 seconds
      const waitUntil = Date.now() + interval;
      while (Date.now() < waitUntil) {
          // Busy-wait loop
      }
  }

  if(finalState != "Succeeded" && finalState != "Failed"){
    console.info("Request has not reached a terminal state . Please poll this URI for your status:"+ operationLocation);
  }
}

async function main() {
  subscriptionQuotaAllocationPutRequestForCompute();
}

main().catch(console.error);