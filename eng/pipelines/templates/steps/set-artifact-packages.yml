parameters:
  PackageInfo: ''
steps:
  # Package-Properties folder now contains the package properties for the packages that should be built or tested.
  # if targeting has been set by matrix, this value will already be populated, can't override it. Handle these cases here.
  - pwsh: |
      $packageProperties = Get-ChildItem -Recurse "${{ parameters.PackageInfo }}" *.json

      $pkgNames = $packageProperties | Foreach-Object { $_.Name } `
        | ForEach-Object { $_.Replace(".json", "") }
      $setting = $packageProperties -join ","

      $changedServicesArray = $packageProperties | Foreach-Object { Get-Content -Raw -Path $_.FullName | ConvertFrom-Json } `
        | ForEach-Object { $_.ServiceDirectory } | Get-Unique
      $changedServices = $changedServicesArray -join " "
      Write-Host "Setting ChangedServices to : `n$changedServices"
      Write-Host "##vso[task.setvariable variable=ChangedServices;]$changedServices"

      Write-Host "Setting ArtifactPackageNames to: `n$setting"
      Write-Host "##vso[task.setvariable variable=ArtifactPackageNames;]$setting"
    displayName: Resolve Targeted Packages
    condition: eq(variables['ArtifactPackageNames'], '')

  - pwsh: |
      Write-Host "This run is targeting: `n$(ArtifactPackageNames) in [$(ChangedServices)]"
    displayName: Resolve Targeted Packages
    condition: ne(variables['ArtifactPackageNames'], '')
